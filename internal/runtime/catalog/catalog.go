/*
Copyright 2021 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package catalog

import (
	"fmt"
	"reflect"

	"github.com/pkg/errors"
	"k8s.io/apimachinery/pkg/conversion"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/kube-openapi/pkg/common"
)

// Catalog defines methods for working with rpc services and their request and response types.
type Catalog struct {
	// scheme allow access api-machinery utilities for handling types and types conversions
	scheme *runtime.Scheme

	// gvhToType and typeToGVH allows tracking relations between hook go types and corresponding gvh.
	gvhToType map[GroupVersionHook]reflect.Type
	typeToGVH map[reflect.Type]GroupVersionHook

	// gvhDescriptors allows tracking relations gvh and corresponding descriptors.
	gvhDescriptors map[GroupVersionHook]hookDescriptor

	// openAPIDefinitionsGetters holds func returning all the openapi definitions for
	// request and responses type for each hook defined in a group version.
	openAPIDefinitionsGetters map[schema.GroupVersion]OpenAPIDefinitionsGetter
}

// OpenAPIDefinitionsGetter defines the signature of a func returning Open API definitions for
// request and response types of a given group version.
// NOTE: the OpenAPIDefinitionsGetter func are automatically generated by openapi-gen.
type OpenAPIDefinitionsGetter func(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition

// New creates a new Catalog. This catalog is pluggable by default.
func New() *Catalog {
	s := &Catalog{
		scheme:                    runtime.NewScheme(),
		gvhToType:                 map[GroupVersionHook]reflect.Type{},
		typeToGVH:                 map[reflect.Type]GroupVersionHook{},
		gvhDescriptors:            map[GroupVersionHook]hookDescriptor{},
		openAPIDefinitionsGetters: map[schema.GroupVersion]OpenAPIDefinitionsGetter{},
	}
	return s
}

func (c *Catalog) Scheme() *runtime.Scheme {
	return c.scheme
}

// RegisterOpenAPIDefinitions sets a func returning all the openapi definitions for request and response types
// of a given group version.
func (c *Catalog) RegisterOpenAPIDefinitions(gv schema.GroupVersion, getter OpenAPIDefinitionsGetter) {
	if _, ok := c.openAPIDefinitionsGetters[gv]; ok {
		panic(fmt.Sprintf("Double registration of openAPI definitions for %v", gv))
	}
	c.openAPIDefinitionsGetters[gv] = getter
}

func (c *Catalog) GetOpenAPIDefinitionsGetter(gv schema.GroupVersion) (getter OpenAPIDefinitionsGetter, err error) {
	if _, ok := c.openAPIDefinitionsGetters[gv]; !ok {
		panic("implement me!") // TODO: handle error
	}
	return c.openAPIDefinitionsGetters[gv], nil
}

// RegisterHook registers a service and its request and response types.
func (c *Catalog) RegisterHook(gv schema.GroupVersion, hook Hook, request, response runtime.Object) {
	t := reflect.TypeOf(hook)
	if t.Kind() != reflect.Ptr {
		panic("All service must be pointers to structs.")
	}
	t = t.Elem()
	if t.Kind() != reflect.Struct {
		panic("All service must be pointers to structs.")
	}

	gvh := GroupVersionHook{
		Group:   gv.Group,
		Version: gv.Version,
		Hook:    t.Name(),
	}
	if oldS, found := c.gvhToType[gvh]; found && oldS != t {
		panic(fmt.Sprintf("Double registration for hook %v: old=%v.%v, new=%v.%v", gvh, oldS.PkgPath(), oldS.Name(), t.PkgPath(), t.Name()))
	}

	c.gvhToType[gvh] = t
	c.typeToGVH[t] = gvh

	c.gvhDescriptors[gvh] = hookDescriptor{
		request:  c.addTypeToScheme(gv, request),
		response: c.addTypeToScheme(gv, response),
	}
}

// addTypeToScheme adds the runtime object's type to scheme and returns the gvk for it.
func (c *Catalog) addTypeToScheme(gv schema.GroupVersion, obj runtime.Object) schema.GroupVersionKind {
	// Adds the object's type to scheme.
	c.scheme.AddKnownTypes(gv, obj)

	// Returns the gvk for the type.
	gvk, err := c.objectKind(obj)
	if err != nil {
		t := reflect.TypeOf(obj).Elem()
		panic(fmt.Sprintf("Type %v.%v registered with more than one gvk", t.PkgPath(), t.Name()))
	}
	return gvk
}

// TODO: consider how to make "consistent" AllKnownHooks and AllKnownParameters

// AllKnownHooks returns the all known gvs.
func (c *Catalog) AllKnownHooks() []GroupVersionHook {
	all := make([]GroupVersionHook, 0, len(c.gvhDescriptors))
	for gvs := range c.gvhDescriptors {
		all = append(all, gvs)
	}
	return all
}

// AllKnownParameters returns the all known gvs.
func (c *Catalog) AllKnownParameters() map[schema.GroupVersionKind]reflect.Type {
	return c.scheme.AllKnownTypes()
}

// HookKind returns the gvs of the service's type, or an error if it's not a pointer
// or is unregistered.
func (c *Catalog) HookKind(hook Hook) (GroupVersionHook, error) {
	v, err := conversion.EnforcePtr(hook)
	if err != nil {
		return emptyGroupVersionService, err
	}
	t := v.Type()

	gvs, ok := c.typeToGVH[t]
	if !ok {
		return emptyGroupVersionService, NewNotRegisteredErrForService(t)
	}
	return gvs, nil
}

// TODO: the following func are confusing
//    the name reminds HookKind (ObjectKind in scheme) but the goal is different - give me the input/output object for an hook -
//    we are conflating validating an object type with ^^

type ObjectKindOption interface {
	ApplyToObjectKind(*ObjectKindOptions)
}

type ValidateObject struct {
	Obj runtime.Object
}

func (o ValidateObject) ApplyToObjectKind(opts *ObjectKindOptions) {
	opts.ValidateObject = o.Obj
}

type ObjectKindOptions struct {
	ValidateObject runtime.Object
}

var emptyGroupVersionKind = schema.GroupVersionKind{}

func (c *Catalog) RequestKind(hook GroupVersionHook, opts ...ObjectKindOption) (schema.GroupVersionKind, error) {
	// TODO: refactor, this is ~ the same there is in ResponseKind
	descriptor, ok := c.gvhDescriptors[hook]
	if !ok {
		return emptyGroupVersionKind, NewNotRegisteredErrForGVS(hook)
	}

	kindOpts := &ObjectKindOptions{}
	for _, o := range opts {
		o.ApplyToObjectKind(kindOpts)
	}

	if kindOpts.ValidateObject != nil {
		gvk, err := c.objectKind(kindOpts.ValidateObject)
		if err != nil {
			return emptyGroupVersionKind, err
		}
		if descriptor.request != gvk {
			return emptyGroupVersionKind, NewInvalidInputErrForGVS(hook, descriptor.request, gvk)
		}
	}
	return descriptor.request, nil
}

func (c *Catalog) ResponseKind(hook GroupVersionHook, opts ...ObjectKindOption) (schema.GroupVersionKind, error) {
	// TODO: refactor, this is ~ the same there is in RequestKind
	descriptor, ok := c.gvhDescriptors[hook]
	if !ok {
		return emptyGroupVersionKind, NewNotRegisteredErrForGVS(hook)
	}

	kindOpts := &ObjectKindOptions{}
	for _, p := range opts {
		p.ApplyToObjectKind(kindOpts)
	}

	if kindOpts.ValidateObject != nil {
		gvk, err := c.objectKind(kindOpts.ValidateObject)
		if err != nil {
			return emptyGroupVersionKind, err
		}
		if descriptor.response != gvk {
			return emptyGroupVersionKind, NewInvalidOutputErrForGVS(hook, descriptor.response, gvk)
		}
	}
	return descriptor.response, nil
}

// ObjectKind returns the gvk of the runtime object's type, or an error if it's not a pointer
// or is unregistered.
func (c *Catalog) objectKind(obj runtime.Object) (schema.GroupVersionKind, error) {
	objectKinds, _, err := c.scheme.ObjectKinds(obj)
	if err != nil {
		return emptyGroupVersionKind, err
	}

	if len(objectKinds) > 1 {
		return emptyGroupVersionKind, errors.Errorf("object has more than one object kinds %s", objectKinds)
	}
	return objectKinds[0], nil
}

func (c *Catalog) NewInput(hook GroupVersionHook) (runtime.Object, error) {
	descriptor, ok := c.gvhDescriptors[hook]
	if !ok {
		return nil, NewNotRegisteredErrForGVS(hook)
	}
	return c.scheme.New(descriptor.request)
}

func (c *Catalog) NewOutput(hook GroupVersionHook) (runtime.Object, error) {
	descriptor, ok := c.gvhDescriptors[hook]
	if !ok {
		return nil, NewNotRegisteredErrForGVS(hook)
	}
	return c.scheme.New(descriptor.response)
}

func (c *Catalog) Convert(in, out interface{}, context interface{}) error {
	return c.scheme.Convert(in, out, context)
}

// TODO: move in a separated file or in another package

// TODO: use a different pattern, e.g. api server errors (thus supporting things like isErrorType)

type notRegisteredErr struct {
	s   reflect.Type
	gvs GroupVersionHook
	gvk schema.GroupVersionKind
	inputGVK  schema.GroupVersionKind
	outputGVK schema.GroupVersionKind
}

func NewNotRegisteredErrForService(s reflect.Type) error {
	return &notRegisteredErr{s: s}
}

func NewNotRegisteredErrForGVS(gvs GroupVersionHook) error {
	return &notRegisteredErr{gvs: gvs}
}

// TODO: another error?
func NewInvalidInputErrForGVS(gvs GroupVersionHook, gvk schema.GroupVersionKind, inputGVK schema.GroupVersionKind) error {
	return &notRegisteredErr{gvs: gvs, gvk: gvk, inputGVK: inputGVK}
}

func NewInvalidOutputErrForGVS(gvs GroupVersionHook, gvk schema.GroupVersionKind, outputGVK schema.GroupVersionKind) error {
	return &notRegisteredErr{gvs: gvs, gvk: gvk, inputGVK: outputGVK}
}

func (e *notRegisteredErr) Error() string {
	if !e.gvs.Empty() {
		if !e.gvk.Empty() && !e.inputGVK.Empty() {
			return fmt.Sprintf("invalid request kind %s: service %s requires request of type %s: %v", e.inputGVK.String(), e.gvs.String(), e.gvk.String())
		}
		if !e.gvk.Empty() && !e.outputGVK.Empty() {
			return fmt.Sprintf("invalid response kind %s: service %s requires response of type %s: %v", e.outputGVK.String(), e.gvs.String(), e.gvk.String())
		}
		return fmt.Sprintf("no kind is registered for the Hook %s", e.gvs.String())
	}
	return fmt.Sprintf("no kind is registered for the Hook %v", e.s)
}
